<!DOCTYPE html>
<html>
<head>
    <title>Project 4 - CS180</title>
    <style>
        body {
            font-family: "Times New Roman", Times, serif;
            margin: 20px;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Two columns */
            gap: 20px;
            margin-top: 20px;
        }
        .image-grid img {
            width: 100%;
            height: auto;
        }
        .image-grid figcaption {
            text-align: center;
            font-size: 18px;
            margin-top: 5px;
            line-height: 1.5;
        }
        h1, h2, h3 {
            margin-bottom: 10px;
        }
        p, li {
            margin-bottom: 20px;
        }
        hr {
            margin: 30px 0;
        }
        center {
            text-align: center; /* Center only content within <center> tags */
        }
    </style>
</head>

<body>
    <h1>Project 4: (Auto)stitching and Photo Mosaics</h1>
    <hr width="100%" size="2">
    <h2>Overview</h2>
    <p>In this project, I continued to play with different aspects of image warping. In particular, I learned how to compute homographies to perform image mosaicing. Image mosaics were created by registering, projective warping, resampling, and compositing two or more images that I took.</p>
    <hr width="100%" size="2">

    <h2>Approach</h2>

    <h3>Recovering Homographies</h3>

    <p>Before I could warp my images into alignment, I needed to recover the parameters of the transformation between each pair of images. This transformation is a homography: <b>p’ = Hp</b>, where <b>H</b> is a 3x3 matrix with 8 degrees of freedom (the lower right corner is a scaling factor, and can be set to 1). I recovered the homography for my image pairs by (1) manually creating a set of of <b>(p’,p)</b> pairs of corresponding points, and (2) using them as input parameters in the function:
    <center><code>H = computeH(im1_pts, im2_pts)</code></center>
    <p><code>im1_pts</code> and <code>im2_pts</code> are n-by-2 matrices holding the (x, y) locations of n point correspondences from the two images. <code>H</code> is the recovered 3x3 homography matrix.</p>

    <h3>Warping the Images</h3>

    <p>Now that I have the parameters of the homography, I can use the homography to warp each image towards the reference image. Let's create another function: <code>imwarped = warpImage(im, H)</code>, where <code>im</code> is the input image to be warped and <code>H</code> is the homography. I used <code>scipy.interpolate.griddata</code> along with inverse warping in my <code>warpImage</code> function and marked pixels without any mapped values as <code>NaN</code> (black).</p>

    <h3>Image Rectification</h3>

    <p>To check if everything was working correctly, I tested my code by performing "rectification" on an image of my monitor.</p>

    <div class="image-grid">
        <figure>
            <img src="imgs/monitor.png" alt="Monitor">
            <figcaption>Original picture of monitor</figcaption>
        </figure>
        <figure>
            <img src="imgs/warped_monitor.png" alt="Warped monitor">
            <figcaption>Warped monitor</figcaption>
        </figure>
    </div>

    <p>Looks good! I know my monitor is a rectangle in real life, so I just used the four corners of the screen to compute a homography and warp it into an actual rectangle.</p>

    <h3>Blending Images into a Mosaic</h3>

    <p>Let's now create an image mosaic of my living room. I'll start out by taking these two pictures:</p>

    <div class="image-grid">
        <figure>
            <img src="imgs/room1.png" alt="Living Room Photo #1">
            <figcaption>Living Room Photo #1</figcaption>
        </figure>
        <figure>
            <img src="imgs/room2.png" alt="Living Room Photo #2">
            <figcaption>Living Room Photo #2</figcaption>
        </figure>
    </div>

    <p>Using the method above, I can warp the first image of my living room to the world of the second image.</p>

    <div class="image-grid">
        <figure>
            <img src="imgs/room1_warped.png" alt="Warped Living Room Photo #1">
            <figcaption>Warped Living Room Photo #1</figcaption>
        </figure>
    </div>

    <p>Nice. They can now perfectly overlap.</p>
    
    <div class="image-grid">
        <figure>
            <img src="imgs/simple_overlap.png" alt="simple overlap">
            <figcaption>Simple overlap</figcaption>
        </figure>
        <figure>
            <img src="imgs/intersection_color.png" alt="intersection color">
            <figcaption>Intersection shown with color (green)</figcaption>
        </figure>
    </div>

    <p>But wait. It's pretty obvious that we're just overlaying two images on top of each other, even though we have warped the first perfectly to the second with the homography. We can try and make this smoother with a simple vertical blending mask, or make use of the <code>scipy.ndimage.distance_transform_edt</code> function (mimicks MATLAB's <code>bwdist</code> function) to create a distance mask, where an alpha value weighs each pixel based on its distance from the centers of the images.</p>
    
    <div class="image-grid">
        <figure>
            <img src="imgs/vert_blend.png" alt="vert">
            <figcaption>Vertical blending</figcaption>
        </figure>
        <figure>
            <img src="imgs/radial_blend.png" alt="radial">
            <figcaption><code>bwdist</code>-like blending</figcaption>
        </figure>
    </div>

    <p>The second option looks pretty nice, so let's crop it to look more like a smooth paranoma:</p>
    <img src="imgs/radial_blend_nice.png" alt="radial">

    <h3>Bells and Whistles</h3>
    <p>Something here!</p>

</body>
</html>
